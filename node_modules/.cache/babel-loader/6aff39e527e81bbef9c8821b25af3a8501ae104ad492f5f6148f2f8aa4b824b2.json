{"ast":null,"code":"var url = require(\"url\");\nvar URL = url.URL;\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar Writable = require(\"stream\").Writable;\nvar assert = require(\"assert\");\nvar debug = require(\"./debug\");\n\n// Create handlers that pass events from native requests\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n});\n\n// Error types with codes\nvar RedirectionError = createErrorType(\"ERR_FR_REDIRECTION_FAILURE\", \"\");\nvar TooManyRedirectsError = createErrorType(\"ERR_FR_TOO_MANY_REDIRECTS\", \"Maximum number of redirects exceeded\");\nvar MaxBodyLengthExceededError = createErrorType(\"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\", \"Request body larger than maxBodyLength limit\");\nvar WriteAfterEndError = createErrorType(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\");\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  this._sanitizeOptions(options);\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  };\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\nRedirectableRequest.prototype.abort = function () {\n  abortRequest(this._currentRequest);\n  this.emit(\"abort\");\n};\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  }\n\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && \"length\" in data)) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({\n      data: data,\n      encoding: encoding\n    });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  } else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data if needed and end\n  if (!data) {\n    this._ended = this._ending = true;\n    this._currentRequest.end(null, null, callback);\n  } else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this;\n  if (callback) {\n    this.on(\"timeout\", callback);\n  }\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener(\"timeout\", socket.destroy);\n    socket.addListener(\"timeout\", socket.destroy);\n  }\n\n  // Sets up a timer to trigger a timeout event\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n    self._timeout = setTimeout(function () {\n      self.emit(\"timeout\");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  }\n\n  // Prevent a timeout from triggering\n  function clearTimer() {\n    clearTimeout(this._timeout);\n    if (callback) {\n      self.removeListener(\"timeout\", callback);\n    }\n    if (!this.socket) {\n      self._currentRequest.removeListener(\"socket\", startTimer);\n    }\n  }\n\n  // Start the timer when the socket is opened\n  if (this.socket) {\n    startTimer(this.socket);\n  } else {\n    this._currentRequest.once(\"socket\", startTimer);\n  }\n  this.on(\"socket\", destroyOnTimeout);\n  this.once(\"response\", clearTimer);\n  this.once(\"error\", clearTimer);\n  return this;\n};\n\n// Proxy all other public ClientRequest methods\n[\"flushHeaders\", \"getHeader\", \"setNoDelay\", \"setSocketKeepAlive\"].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () {\n      return this._currentRequest[property];\n    }\n  });\n});\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    } else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n};\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    this.emit(\"error\", new TypeError(\"Unsupported protocol \" + protocol));\n    return;\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request\n  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options);\n\n  // Set up event handlers\n  request._redirectable = this;\n  for (var e = 0; e < events.length; e++) {\n    request.on(events[e], eventHandlers[events[e]]);\n  }\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n      /* istanbul ignore else */\n      if (request === self._currentRequest) {\n        // Report any write errors\n        /* istanbul ignore if */\n        if (error) {\n          self.emit(\"error\", error);\n        }\n        // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          /* istanbul ignore else */\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        }\n        // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    })();\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode\n    });\n  }\n\n  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  var location = response.headers.location;\n  if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {\n    // Abort the current request\n    abortRequest(this._currentRequest);\n    // Discard the remainder of the response to avoid waiting for data\n    response.destroy();\n\n    // RFC7231§6.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new TooManyRedirectsError());\n      return;\n    }\n\n    // RFC7231§6.4: Automatic redirection needs to done with\n    // care for methods not known to be safe, […]\n    // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change\n    // the request method from POST to GET for the subsequent request.\n    if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\n    // RFC7231§6.4.4: The 303 (See Other) status code indicates that\n    // the server is redirecting the user agent to a different resource […]\n    // A user agent can perform a retrieval request targeting that URI\n    // (a GET or HEAD request if using HTTP) […]\n    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n      this._options.method = \"GET\";\n      // Drop a possible entity and headers related to it\n      this._requestBodyBuffers = [];\n      removeMatchingHeaders(/^content-/i, this._options.headers);\n    }\n\n    // Drop the Host header, as the redirect might lead to a different host\n    var previousHostName = removeMatchingHeaders(/^host$/i, this._options.headers) || url.parse(this._currentUrl).hostname;\n\n    // Create the redirected request\n    var redirectUrl = url.resolve(this._currentUrl, location);\n    debug(\"redirecting to\", redirectUrl);\n    this._isRedirect = true;\n    var redirectUrlParts = url.parse(redirectUrl);\n    Object.assign(this._options, redirectUrlParts);\n\n    // Drop the Authorization header if redirecting to another host\n    if (redirectUrlParts.hostname !== previousHostName) {\n      removeMatchingHeaders(/^authorization$/i, this._options.headers);\n    }\n\n    // Evaluate the beforeRedirect callback\n    if (typeof this._options.beforeRedirect === \"function\") {\n      var responseDetails = {\n        headers: response.headers\n      };\n      try {\n        this._options.beforeRedirect.call(null, this._options, responseDetails);\n      } catch (err) {\n        this.emit(\"error\", err);\n        return;\n      }\n      this._sanitizeOptions(this._options);\n    }\n\n    // Perform the redirected request\n    try {\n      this._performRequest();\n    } catch (cause) {\n      var error = new RedirectionError(\"Redirected request failed: \" + cause.message);\n      error.cause = cause;\n      this.emit(\"error\", error);\n    }\n  } else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n  }\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    function request(input, options, callback) {\n      // Parse parameters\n      if (typeof input === \"string\") {\n        var urlStr = input;\n        try {\n          input = urlToOptions(new URL(urlStr));\n        } catch (err) {\n          /* istanbul ignore next */\n          input = url.parse(urlStr);\n        }\n      } else if (URL && input instanceof URL) {\n        input = urlToOptions(input);\n      } else {\n        callback = options;\n        options = input;\n        input = {\n          protocol: protocol\n        };\n      }\n      if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n      }\n\n      // Set defaults\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    }\n\n    // Executes a GET request, following redirects\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    }\n\n    // Expose the properties on the wrapped protocol\n    Object.defineProperties(wrappedProtocol, {\n      request: {\n        value: request,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      },\n      get: {\n        value: get,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }\n    });\n  });\n  return exports;\n}\n\n/* istanbul ignore next */\nfunction noop() {/* empty */}\n\n// from https://github.com/nodejs/node/blob/master/lib/internal/url.js\nfunction urlToOptions(urlObject) {\n  var options = {\n    protocol: urlObject.protocol,\n    hostname: urlObject.hostname.startsWith(\"[\") ? /* istanbul ignore next */\n    urlObject.hostname.slice(1, -1) : urlObject.hostname,\n    hash: urlObject.hash,\n    search: urlObject.search,\n    pathname: urlObject.pathname,\n    path: urlObject.pathname + urlObject.search,\n    href: urlObject.href\n  };\n  if (urlObject.port !== \"\") {\n    options.port = Number(urlObject.port);\n  }\n  return options;\n}\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n  return lastValue;\n}\nfunction createErrorType(code, defaultMessage) {\n  function CustomError(message) {\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message || defaultMessage;\n  }\n  CustomError.prototype = new Error();\n  CustomError.prototype.constructor = CustomError;\n  CustomError.prototype.name = \"Error [\" + code + \"]\";\n  CustomError.prototype.code = code;\n  return CustomError;\n}\nfunction abortRequest(request) {\n  for (var e = 0; e < events.length; e++) {\n    request.removeListener(events[e], eventHandlers[events[e]]);\n  }\n  request.on(\"error\", noop);\n  request.abort();\n}\n\n// Exports\nmodule.exports = wrap({\n  http: http,\n  https: https\n});\nmodule.exports.wrap = wrap;","map":{"version":3,"names":["url","require","URL","http","https","Writable","assert","debug","events","eventHandlers","Object","create","forEach","event","arg1","arg2","arg3","_redirectable","emit","RedirectionError","createErrorType","TooManyRedirectsError","MaxBodyLengthExceededError","WriteAfterEndError","RedirectableRequest","options","responseCallback","call","_sanitizeOptions","_options","_ended","_ending","_redirectCount","_redirects","_requestBodyLength","_requestBodyBuffers","on","self","_onNativeResponse","response","_processResponse","_performRequest","prototype","abort","abortRequest","_currentRequest","write","data","encoding","callback","TypeError","length","maxBodyLength","push","end","currentRequest","setHeader","name","value","headers","removeHeader","setTimeout","msecs","destroyOnTimeout","socket","removeListener","destroy","addListener","startTimer","_timeout","clearTimeout","clearTimer","once","method","a","b","property","defineProperty","get","host","hostname","pathname","path","searchPos","indexOf","substring","search","protocol","nativeProtocol","nativeProtocols","agents","scheme","substr","agent","request","_currentUrl","format","e","_isRedirect","i","buffers","writeNext","error","buffer","finished","statusCode","trackRedirects","location","followRedirects","maxRedirects","test","removeMatchingHeaders","previousHostName","parse","redirectUrl","resolve","redirectUrlParts","assign","beforeRedirect","responseDetails","err","cause","message","responseUrl","redirects","wrap","protocols","exports","keys","wrappedProtocol","input","urlStr","urlToOptions","equal","wrappedRequest","defineProperties","configurable","enumerable","writable","noop","urlObject","startsWith","slice","hash","href","port","Number","regex","lastValue","header","code","defaultMessage","CustomError","Error","captureStackTrace","constructor","module"],"sources":["/home/nachiket/Desktop/NEWS InShorts/node_modules/follow-redirects/index.js"],"sourcesContent":["var url = require(\"url\");\nvar URL = url.URL;\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar Writable = require(\"stream\").Writable;\nvar assert = require(\"assert\");\nvar debug = require(\"./debug\");\n\n// Create handlers that pass events from native requests\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n});\n\n// Error types with codes\nvar RedirectionError = createErrorType(\n  \"ERR_FR_REDIRECTION_FAILURE\",\n  \"\"\n);\nvar TooManyRedirectsError = createErrorType(\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\n  \"Maximum number of redirects exceeded\"\n);\nvar MaxBodyLengthExceededError = createErrorType(\n  \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\",\n  \"Request body larger than maxBodyLength limit\"\n);\nvar WriteAfterEndError = createErrorType(\n  \"ERR_STREAM_WRITE_AFTER_END\",\n  \"write after end\"\n);\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  this._sanitizeOptions(options);\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  };\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\nRedirectableRequest.prototype.abort = function () {\n  abortRequest(this._currentRequest);\n  this.emit(\"abort\");\n};\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  }\n\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data if needed and end\n  if (!data) {\n    this._ended = this._ending = true;\n    this._currentRequest.end(null, null, callback);\n  }\n  else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this;\n  if (callback) {\n    this.on(\"timeout\", callback);\n  }\n\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener(\"timeout\", socket.destroy);\n    socket.addListener(\"timeout\", socket.destroy);\n  }\n\n  // Sets up a timer to trigger a timeout event\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n    self._timeout = setTimeout(function () {\n      self.emit(\"timeout\");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  }\n\n  // Prevent a timeout from triggering\n  function clearTimer() {\n    clearTimeout(this._timeout);\n    if (callback) {\n      self.removeListener(\"timeout\", callback);\n    }\n    if (!this.socket) {\n      self._currentRequest.removeListener(\"socket\", startTimer);\n    }\n  }\n\n  // Start the timer when the socket is opened\n  if (this.socket) {\n    startTimer(this.socket);\n  }\n  else {\n    this._currentRequest.once(\"socket\", startTimer);\n  }\n\n  this.on(\"socket\", destroyOnTimeout);\n  this.once(\"response\", clearTimer);\n  this.once(\"error\", clearTimer);\n\n  return this;\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n};\n\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    this.emit(\"error\", new TypeError(\"Unsupported protocol \" + protocol));\n    return;\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options);\n\n  // Set up event handlers\n  request._redirectable = this;\n  for (var e = 0; e < events.length; e++) {\n    request.on(events[e], eventHandlers[events[e]]);\n  }\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n      /* istanbul ignore else */\n      if (request === self._currentRequest) {\n        // Report any write errors\n        /* istanbul ignore if */\n        if (error) {\n          self.emit(\"error\", error);\n        }\n        // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          /* istanbul ignore else */\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        }\n        // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode,\n    });\n  }\n\n  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  var location = response.headers.location;\n  if (location && this._options.followRedirects !== false &&\n      statusCode >= 300 && statusCode < 400) {\n    // Abort the current request\n    abortRequest(this._currentRequest);\n    // Discard the remainder of the response to avoid waiting for data\n    response.destroy();\n\n    // RFC7231§6.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new TooManyRedirectsError());\n      return;\n    }\n\n    // RFC7231§6.4: Automatic redirection needs to done with\n    // care for methods not known to be safe, […]\n    // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change\n    // the request method from POST to GET for the subsequent request.\n    if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\n        // RFC7231§6.4.4: The 303 (See Other) status code indicates that\n        // the server is redirecting the user agent to a different resource […]\n        // A user agent can perform a retrieval request targeting that URI\n        // (a GET or HEAD request if using HTTP) […]\n        (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n      this._options.method = \"GET\";\n      // Drop a possible entity and headers related to it\n      this._requestBodyBuffers = [];\n      removeMatchingHeaders(/^content-/i, this._options.headers);\n    }\n\n    // Drop the Host header, as the redirect might lead to a different host\n    var previousHostName = removeMatchingHeaders(/^host$/i, this._options.headers) ||\n      url.parse(this._currentUrl).hostname;\n\n    // Create the redirected request\n    var redirectUrl = url.resolve(this._currentUrl, location);\n    debug(\"redirecting to\", redirectUrl);\n    this._isRedirect = true;\n    var redirectUrlParts = url.parse(redirectUrl);\n    Object.assign(this._options, redirectUrlParts);\n\n    // Drop the Authorization header if redirecting to another host\n    if (redirectUrlParts.hostname !== previousHostName) {\n      removeMatchingHeaders(/^authorization$/i, this._options.headers);\n    }\n\n    // Evaluate the beforeRedirect callback\n    if (typeof this._options.beforeRedirect === \"function\") {\n      var responseDetails = { headers: response.headers };\n      try {\n        this._options.beforeRedirect.call(null, this._options, responseDetails);\n      }\n      catch (err) {\n        this.emit(\"error\", err);\n        return;\n      }\n      this._sanitizeOptions(this._options);\n    }\n\n    // Perform the redirected request\n    try {\n      this._performRequest();\n    }\n    catch (cause) {\n      var error = new RedirectionError(\"Redirected request failed: \" + cause.message);\n      error.cause = cause;\n      this.emit(\"error\", error);\n    }\n  }\n  else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n  }\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    function request(input, options, callback) {\n      // Parse parameters\n      if (typeof input === \"string\") {\n        var urlStr = input;\n        try {\n          input = urlToOptions(new URL(urlStr));\n        }\n        catch (err) {\n          /* istanbul ignore next */\n          input = url.parse(urlStr);\n        }\n      }\n      else if (URL && (input instanceof URL)) {\n        input = urlToOptions(input);\n      }\n      else {\n        callback = options;\n        options = input;\n        input = { protocol: protocol };\n      }\n      if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n      }\n\n      // Set defaults\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength,\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    }\n\n    // Executes a GET request, following redirects\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    }\n\n    // Expose the properties on the wrapped protocol\n    Object.defineProperties(wrappedProtocol, {\n      request: { value: request, configurable: true, enumerable: true, writable: true },\n      get: { value: get, configurable: true, enumerable: true, writable: true },\n    });\n  });\n  return exports;\n}\n\n/* istanbul ignore next */\nfunction noop() { /* empty */ }\n\n// from https://github.com/nodejs/node/blob/master/lib/internal/url.js\nfunction urlToOptions(urlObject) {\n  var options = {\n    protocol: urlObject.protocol,\n    hostname: urlObject.hostname.startsWith(\"[\") ?\n      /* istanbul ignore next */\n      urlObject.hostname.slice(1, -1) :\n      urlObject.hostname,\n    hash: urlObject.hash,\n    search: urlObject.search,\n    pathname: urlObject.pathname,\n    path: urlObject.pathname + urlObject.search,\n    href: urlObject.href,\n  };\n  if (urlObject.port !== \"\") {\n    options.port = Number(urlObject.port);\n  }\n  return options;\n}\n\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n  return lastValue;\n}\n\nfunction createErrorType(code, defaultMessage) {\n  function CustomError(message) {\n    Error.captureStackTrace(this, this.constructor);\n    this.message = message || defaultMessage;\n  }\n  CustomError.prototype = new Error();\n  CustomError.prototype.constructor = CustomError;\n  CustomError.prototype.name = \"Error [\" + code + \"]\";\n  CustomError.prototype.code = code;\n  return CustomError;\n}\n\nfunction abortRequest(request) {\n  for (var e = 0; e < events.length; e++) {\n    request.removeListener(events[e], eventHandlers[events[e]]);\n  }\n  request.on(\"error\", noop);\n  request.abort();\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}